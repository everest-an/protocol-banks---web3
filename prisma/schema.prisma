generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model BatchJob {
  id            String   @id @default(uuid())
  user_id       String
  status        String   @default("QUEUED")
  total_lines   Int      @default(0)
  parsed_count  Int      @default(0)
  invalid_count Int      @default(0)
  chunks        Int      @default(0)
  error_message String?
  file_url      String?
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  batch_chunks BatchChunk[]

  @@map("batch_jobs")
}

model BatchChunk {
  id              String   @id @default(uuid())
  job_id          String
  chunk_index     Int
  recipient_count Int
  status          String   @default("PENDING")
  data            Json
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  job BatchJob @relation(fields: [job_id], references: [id], onDelete: Cascade)

  @@index([job_id])
  @@map("batch_chunks")
}

model BatchPayment {
  id                String    @id @default(uuid())
  batch_id          String    @unique
  from_address      String
  total_amount      Float
  total_items       Int
  token             String    @default("USDC")
  chain             String    @default("base") // "ethereum" | "tron" | "arbitrum" | "base"
  chain_id          Int? // EVM chain ID (null for TRON)
  network_type      String    @default("EVM") // "EVM" | "TRON"
  status            String    @default("pending")
  items             Json // Can contain mixed EVM + TRON addresses
  memo              String?
  results           Json?
  fee               Float?
  settlement_method String?
  executed_at       DateTime?
  created_at        DateTime  @default(now())

  @@index([from_address])
  @@index([batch_id])
  @@index([chain])
  @@index([network_type])
  @@map("batch_payments")
}

model Payment {
  id           String    @id @default(uuid())
  from_address String
  to_address   String
  amount       String
  token        String
  token_symbol String?
  chain        String // "ethereum" | "tron" | "arbitrum" | "base" | "bsc"
  network_type String?   @default("EVM") // "EVM" | "TRON" - for easier filtering
  chain_id     Int? // EVM chain ID (null for TRON)
  status       String    @default("pending")
  type         String // "sent" | "received"
  method       String? // "eip3009" | "direct" | "batch" | "trc20"
  tx_hash      String?

  // TRON-specific fields
  energy_used    BigInt? // TRON energy consumption
  bandwidth_used BigInt? // TRON bandwidth consumption

  // EVM-specific fields
  gas_used  BigInt? // Gas used (EVM)
  gas_price BigInt? // Gas price (EVM)

  confirmations Int      @default(0) // Block confirmations
  block_number  BigInt? // Block number

  created_at   DateTime  @default(now())
  completed_at DateTime?
  created_by   String?
  vendor_name  String?
  category     String?
  memo         String?
  notes        String?
  amount_usd   Float?
  is_external  Boolean   @default(false)
  tags         String[]  @default([])
  vendor_id    String?

  group_id String?
  vendor   Vendor?       @relation(fields: [vendor_id], references: [id])
  group    PaymentGroup? @relation(fields: [group_id], references: [id])

  @@index([created_by])
  @@index([status])
  @@index([type])
  @@index([vendor_id])
  @@index([group_id])
  @@index([chain])
  @@index([network_type])
  @@index([tx_hash])
  @@map("payments")
}

model PaymentGroup {
  id            String   @id @default(uuid())
  name          String
  description   String?
  owner_address String
  purpose       String?
  tags          String[] @default([])
  total_amount  String   @default("0")
  payment_count Int      @default(0)
  status        String   @default("open")
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  payments Payment[]

  @@index([owner_address])
  @@index([status])
  @@map("payment_groups")
}

model Vendor {
  id                       String    @id @default(uuid())
  name                     String
  wallet_address           String // Primary address (backward compatibility)
  owner_address            String
  ens_name                 String?
  company_name             String?
  category                 String?
  tier                     String?   @default("vendor") // "subsidiary" | "partner" | "vendor"
  chain                    String?   @default("Ethereum") // Primary chain (backward compatibility)
  last_chain               String? // Last chain used for payment
  last_wallet_type         String? // Last wallet type used (MetaMask, Safe, etc.)
  email                    String?
  contact_email            String?
  contact_name             String?
  notes                    String?
  tags                     String[]  @default([])
  reputation_tag           String? // "whale" | "active" | "newbie" | "inactive"
  monthly_volume           String?
  transaction_count        Int       @default(0)
  on_chain_balance         Float?    @default(0)
  ltv                      Float?    @default(0)
  last_payment_at          DateTime?
  integrity_hash           String?
  created_by               String?
  address_changed_at       DateTime?
  address_change_signature String?
  created_at               DateTime  @default(now())
  updated_at               DateTime  @updatedAt

  payments  Payment[]
  addresses VendorAddress[] // Multi-network address support

  @@index([owner_address])
  @@index([created_by])
  @@index([wallet_address])
  @@map("vendors")
}

// New model for multi-network vendor addresses
model VendorAddress {
  id          String   @id @default(uuid())
  vendor_id   String
  network     String // "ethereum" | "tron" | "arbitrum" | "base" | "bsc"
  address     String
  label       String? // Optional label (e.g., "Main TRON wallet")
  is_primary  Boolean  @default(false)
  verified_at DateTime? // When address was verified
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  vendor Vendor @relation(fields: [vendor_id], references: [id], onDelete: Cascade)

  @@unique([vendor_id, network]) // One address per network per vendor
  @@index([vendor_id])
  @@index([address])
  @@map("vendor_addresses")
}

model ApiKey {
  id                    String    @id @default(uuid())
  name                  String
  key_hash              String    @unique
  key_prefix            String
  owner_address         String
  permissions           String[] // Array of permissions
  rate_limit_per_minute Int       @default(60)
  rate_limit_per_day    Int       @default(10000)
  allowed_ips           String[]  @default([])
  allowed_origins       String[]  @default([])
  usage_count           Int       @default(0)
  is_active             Boolean   @default(true)
  expires_at            DateTime?
  last_used_at          DateTime?
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt

  usage_logs ApiKeyUsageLog[]

  @@index([key_prefix])
  @@index([owner_address])
  @@map("api_keys")
}

model ApiKeyUsageLog {
  id               String   @id @default(uuid())
  api_key_id       String
  endpoint         String
  method           String
  status_code      Int
  response_time_ms Int
  ip_address       String?
  user_agent       String?
  created_at       DateTime @default(now())

  api_key ApiKey @relation(fields: [api_key_id], references: [id], onDelete: Cascade)

  @@index([api_key_id])
  @@map("api_key_usage_logs")
}

model NotificationPreference {
  id           String   @id @default(uuid())
  user_address String   @unique
  preferences  Json // Stores all boolean flags
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@map("notification_preferences")
}

model PushSubscription {
  id           String   @id @default(uuid())
  user_address String
  endpoint     String   @unique
  p256dh       String
  auth         String
  created_at   DateTime @default(now())

  @@index([user_address])
  @@map("push_subscriptions")
}

model Webhook {
  id            String   @id @default(uuid())
  name          String
  url           String
  owner_address String
  events        String[]
  secret_hash   String
  is_active     Boolean  @default(true)
  retry_count   Int      @default(3)
  timeout_ms    Int      @default(30000)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  deliveries WebhookDelivery[]

  @@index([owner_address])
  @@map("webhooks")
}

model WebhookDelivery {
  id              String    @id @default(uuid())
  webhook_id      String
  event_type      String
  payload         Json
  status          String    @default("pending")
  attempts        Int       @default(0)
  last_attempt_at DateTime?
  next_retry_at   DateTime?
  response_status Int?
  response_body   String?
  error_message   String?
  created_at      DateTime  @default(now())
  delivered_at    DateTime?

  webhook Webhook @relation(fields: [webhook_id], references: [id], onDelete: Cascade)

  @@index([webhook_id])
  @@map("webhook_deliveries")
}

model Team {
  id            String   @id @default(uuid())
  name          String
  description   String?
  owner_address String
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  members    TeamMember[]
  audit_logs TeamAuditLog[]

  @@map("teams")
}

model TeamMember {
  id             String    @id @default(uuid())
  team_id        String
  member_address String
  role           String
  status         String
  invited_by     String
  invited_at     DateTime  @default(now())
  accepted_at    DateTime?

  team Team @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@unique([team_id, member_address])
  @@map("team_members")
}

model TeamAuditLog {
  id           String   @id @default(uuid())
  team_id      String
  user_address String
  action       String
  details      Json
  created_at   DateTime @default(now())

  team Team @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@map("team_audit_logs")
}

model PaymentProposal {
  id                    String    @id @default(uuid())
  agent_id              String
  owner_address         String
  recipient_address     String
  amount                String
  token                 String
  chain_id              Int
  reason                String
  metadata              Json?
  status                String    @default("pending")
  rejection_reason      String?
  budget_id             String?
  x402_authorization_id String?
  tx_hash               String?
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt
  approved_at           DateTime?
  executed_at           DateTime?

  @@index([owner_address])
  @@index([agent_id])
  @@index([status])
  @@map("payment_proposals")
}

model ScheduledPayment {
  id               String    @id @default(uuid())
  owner_address    String
  team_id          String?
  name             String
  description      String?
  recipients       Json
  schedule_type    String
  schedule_config  Json?
  timezone         String    @default("UTC")
  next_execution   DateTime
  max_executions   Int?
  execution_count  Int       @default(0)
  chain_id         Int       @default(42161)
  token            String    @default("USDT")
  status           String    @default("active")
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt
  last_execution   DateTime?
  total_executions Int       @default(0)

  logs ScheduledPaymentLog[]

  @@index([owner_address])
  @@index([team_id])
  @@index([status])
  @@index([next_execution])
  @@map("scheduled_payments")
}

model ScheduledPaymentLog {
  id                   String   @id @default(uuid())
  scheduled_payment_id String
  status               String
  executed_at          DateTime @default(now())
  total_amount         String   @default("0")
  recipients_count     Int      @default(0)
  successful_count     Int      @default(0)
  failed_count         Int      @default(0)
  details              Json?
  tx_hash              String?
  error_message        String?

  scheduled_payment ScheduledPayment @relation(fields: [scheduled_payment_id], references: [id], onDelete: Cascade)

  @@index([scheduled_payment_id])
  @@index([executed_at])
  @@map("scheduled_payment_logs")
}

model Subscription {
  id                String    @id @default(uuid())
  owner_address     String
  service_name      String
  wallet_address    String
  amount            String
  token             String
  frequency         String
  status            String    @default("active")
  next_payment_date DateTime?
  last_payment_date DateTime?
  last_tx_hash      String?
  total_paid        String    @default("0")
  payment_count     Int       @default(0)
  chain_id          Int
  memo              String?
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  // Auto Pay fields
  use_case                 String    @default("individual")
  max_authorized_amount    String?
  authorization_expires_at DateTime?
  schedule_day             Int?
  schedule_time            String?
  timezone                 String    @default("UTC")
  description              String?
  recipients               Json?

  payments       SubscriptionPayment[]
  authorizations SubscriptionAuthorization[]

  @@index([owner_address])
  @@index([status])
  @@index([use_case])
  @@index([next_payment_date])
  @@map("subscriptions")
}

model SubscriptionPayment {
  id              String   @id @default(uuid())
  subscription_id String
  amount          String
  tx_hash         String?
  status          String   @default("completed")
  error_message   String?
  created_at      DateTime @default(now())

  subscription Subscription @relation(fields: [subscription_id], references: [id], onDelete: Cascade)

  @@index([subscription_id])
  @@map("subscription_payments")
}

model SubscriptionAuthorization {
  id              String    @id @default(uuid())
  subscription_id String
  status          String    @default("active")
  signature       String
  max_amount      String?
  expires_at      DateTime?
  created_at      DateTime  @default(now())

  subscription Subscription @relation(fields: [subscription_id], references: [id], onDelete: Cascade)

  @@index([subscription_id])
  @@map("subscription_authorizations")
}

model X402Authorization {
  id              String   @id @default(uuid())
  proposal_id     String
  version         String   @default("1.0")
  network         String
  payment_address String
  from_address    String
  amount          String
  token           String
  chain_id        Int
  memo            String?
  nonce           String
  valid_after     DateTime
  valid_before    DateTime
  signature       String?
  status          String
  tx_hash         String?
  transfer_id     String?
  expires_at      DateTime
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  @@index([proposal_id])
  @@index([from_address, payment_address])
  @@index([status])
  @@map("x402_authorizations")
}

model X402Settlement {
  id                String   @id @default(uuid())
  authorization_id  String
  transaction_hash  String
  chain_id          Int
  amount            Float
  fee               Float    @default(0)
  token             String
  from_address      String
  to_address        String
  settlement_method String
  status            String   @default("completed")
  settled_at        DateTime @default(now())

  @@index([authorization_id])
  @@map("x402_settlements")
}

model PaymentLog {
  id           String   @id @default(uuid())
  type         String
  transfer_id  String?
  from_address String
  to_address   String
  amount       String
  token        String
  chain_id     Int?
  tx_hash      String?
  status       String
  created_at   DateTime @default(now())

  @@index([transfer_id])
  @@map("payment_logs")
}

model PaymentSplitTemplate {
  id            String   @id @default(uuid())
  owner_address String
  team_id       String?
  name          String
  description   String?
  recipients    Json
  is_active     Boolean  @default(true)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@index([owner_address])
  @@index([team_id])
  @@map("payment_split_templates")
}

model PaymentSplitExecution {
  id            String   @id @default(uuid())
  owner_address String
  template_id   String?
  team_id       String?
  total_amount  String
  token         String
  chain_id      Int
  recipients    Json
  status        String   @default("pending")
  tx_hash       String?
  error_message String?
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@index([owner_address])
  @@index([template_id])
  @@map("payment_split_executions")
}

model PaymentChannel {
  id                     String    @id
  provider_id            String
  consumer_id            String
  consumer_address       String
  session_key_public_key String?
  deposit_amount         String    @default("0")
  spent_amount           String    @default("0")
  pending_amount         String    @default("0")
  settlement_threshold   String    @default("10")
  auto_settle_interval   Int       @default(3600)
  status                 String    @default("open")
  last_settlement_at     DateTime?
  expires_at             DateTime
  created_at             DateTime  @default(now())
  closed_at              DateTime?
  last_activity_at       DateTime?

  payments ChannelPayment[]

  @@map("payment_channels")
}

model ChannelPayment {
  id               String   @id
  channel_id       String
  amount           String
  resource         String
  metadata         Json?
  status           String   @default("pending")
  settled_in_batch String?
  created_at       DateTime @default(now())

  channel PaymentChannel @relation(fields: [channel_id], references: [id])

  @@map("channel_payments")
}

model ChannelSettlement {
  id               String    @id
  channel_id       String
  amount           String
  status           String    @default("processing")
  transaction_hash String?
  created_at       DateTime  @default(now())
  completed_at     DateTime?

  @@map("channel_settlements")
}

model MultisigWallet {
  id            String   @id @default(uuid())
  name          String
  address       String   @unique
  chain_id      Int
  threshold     Int
  signers       String[]
  owner_address String
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  transactions MultisigTransaction[]

  @@map("multisig_wallets")
}

model MultisigTransaction {
  id                String   @id @default(uuid())
  multisig_id       String
  to_address        String
  value             String
  data              String?
  nonce             Int
  status            String
  threshold         Int
  execution_tx_hash String?
  error_message     String?
  created_by        String
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  multisig_wallet MultisigWallet         @relation(fields: [multisig_id], references: [id]) // Renamed relation field to avoid conflict with field name if any
  confirmations   MultisigConfirmation[]

  @@map("multisig_transactions")
}

model MultisigConfirmation {
  id             String   @id @default(uuid())
  transaction_id String
  signer_address String
  signature      String
  confirmed_at   DateTime @default(now())

  transaction MultisigTransaction @relation(fields: [transaction_id], references: [id])

  @@unique([transaction_id, signer_address])
  @@map("multisig_confirmations")
}

model Agent {
  id                    String    @id @default(uuid())
  owner_address         String
  name                  String
  description           String?
  type                  String    @default("custom")
  avatar_url            String?
  api_key_hash          String    @unique
  api_key_prefix        String
  webhook_url           String?
  webhook_secret_hash   String?
  status                String    @default("active")
  auto_execute_enabled  Boolean   @default(false)
  auto_execute_rules    Json?
  rate_limit_per_minute Int       @default(60)
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt
  last_active_at        DateTime?

  budgets            AgentBudget[]
  activities         AgentActivity[]
  webhook_deliveries AgentWebhookDelivery[]
  card               AgentCard?

  @@map("agents")
}

model AgentBudget {
  id               String    @id @default(uuid())
  agent_id         String
  owner_address    String
  amount           String
  token            String
  chain_id         Int?
  period           String
  used_amount      String    @default("0")
  remaining_amount String
  period_start     DateTime
  period_end       DateTime?
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt

  agent Agent @relation(fields: [agent_id], references: [id])

  @@map("agent_budgets")
}

model AgentActivity {
  id            String   @id @default(uuid())
  agent_id      String
  owner_address String
  action        String
  details       Json
  ip_address    String?
  user_agent    String?
  created_at    DateTime @default(now())

  // Relations
  agent Agent @relation(fields: [agent_id], references: [id], onDelete: Cascade)

  @@index([agent_id])
  @@index([owner_address])
  @@map("agent_activities")
}

model AgentWebhookDelivery {
  id              String    @id @default(uuid())
  agent_id        String
  event_type      String
  payload         Json
  status          String    @default("pending")
  attempts        Int       @default(0)
  last_attempt_at DateTime?
  next_retry_at   DateTime?
  response_status Int?
  error_message   String?
  created_at      DateTime  @default(now())
  delivered_at    DateTime?

  agent Agent @relation(fields: [agent_id], references: [id], onDelete: Cascade)

  @@index([agent_id])
  @@index([status])
  @@map("agent_webhook_deliveries")
}

model SubscriptionPlan {
  id            String   @id @default(uuid())
  name          String   @unique
  price_monthly Float
  limits        Json
  features      String[]
  is_active     Boolean  @default(true)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  subscriptions UserSubscription[]

  @@map("subscription_plans")
}

model UserSubscription {
  id                   String    @id @default(uuid())
  user_address         String    @unique
  plan_id              String
  status               String
  current_period_start DateTime
  current_period_end   DateTime
  cancelled_at         DateTime?
  created_at           DateTime  @default(now())
  updated_at           DateTime  @updatedAt

  plan SubscriptionPlan @relation(fields: [plan_id], references: [id])

  @@index([user_address])
  @@map("user_subscriptions")
}

model BillingHistory {
  id           String   @id @default(uuid())
  user_address String
  event_type   String
  amount       Float
  description  String?
  plan_id      String?
  invoice_url  String?
  created_at   DateTime @default(now())

  @@index([user_address])
  @@map("billing_history")
}

model UsageMetric {
  id                       String   @id @default(uuid())
  user_address             String
  period_start             DateTime
  recipients_used          Int      @default(0)
  scheduled_payments_count Int      @default(0)
  team_members_count       Int      @default(0)
  transactions_count       Int      @default(0)
  total_volume             Float    @default(0)
  updated_at               DateTime @updatedAt

  @@unique([user_address, period_start])
  @@map("usage_metrics")
}

model TransactionFee {
  id             String   @id @default(uuid())
  user_address   String
  payment_id     String
  fee_amount     Float
  fee_percentage Float
  created_at     DateTime @default(now())

  @@index([user_address])
  @@index([payment_id])
  @@map("transaction_fees")
}

model Invoice {
  id                String  @id @default(uuid())
  invoice_id        String  @unique
  recipient_address String
  amount            Float
  amount_fiat       Float?
  fiat_currency     String?
  token             String  @default("USDC")
  chain             String? @default("Ethereum") // Ethereum, Polygon, BSC, Arbitrum, Optimism
  description       String?
  merchant_name     String?
  status            String  @default("pending") // pending, paid, expired, cancelled
  signature         String?
  tx_hash           String? // Transaction hash on chain

  // Customer Info
  customer_name   String?
  customer_email  String?
  customer_wallet String?

  // Metadata
  metadata Json?

  // Dates
  paid_at    DateTime?
  expires_at DateTime
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  @@index([recipient_address])
  @@index([invoice_id])
  @@map("invoices")
}

// ============================================================================
// Auth & Identity Models
// ============================================================================

model AuthUser {
  id                   String   @id @default(uuid())
  email                String?  @unique
  email_verified       Boolean  @default(false)
  wallet_address       String?
  has_wallet           Boolean  @default(false)
  google_id            String?  @unique
  apple_id             String?  @unique
  onboarding_completed Boolean  @default(false)
  created_at           DateTime @default(now())

  embedded_wallets EmbeddedWallet[]
  magic_links      MagicLink[]
  merchants        Merchant[]
  corporate_cards  CorporateCard[]
  fiat_orders      FiatOrder[]

  @@index([email])
  @@index([wallet_address])
  @@index([google_id])
  @@index([apple_id])
  @@map("auth_users")
}

model EmbeddedWallet {
  id                     String   @id @default(uuid())
  user_id                String
  address                String
  wallet_address         String?
  server_share           String?
  server_iv              String?
  server_share_encrypted String?
  server_share_iv        String?
  encrypted_share        String?
  encrypted_share_b      String?
  recovery_share         String?
  recovery_iv            String?
  recovery_hash          String?
  share_c_hash           String?
  encrypted_key_share    String?
  salt                   String?
  chain_type             String   @default("EVM")
  is_primary             Boolean  @default(true)
  derivation_path        String?
  created_at             DateTime @default(now())

  user AuthUser @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([address])
  @@index([wallet_address])
  @@map("embedded_wallets")
}

model MagicLink {
  id         String    @id @default(uuid())
  email      String
  token_hash String
  expires_at DateTime
  used       Boolean   @default(false)
  used_at    DateTime?
  ip_address String?
  user_agent String?
  created_at DateTime  @default(now())

  user AuthUser? @relation(fields: [email], references: [email], onDelete: Cascade)

  @@index([email])
  @@index([token_hash])
  @@map("magic_links")
}

model SessionKey {
  id              String    @id @default(uuid())
  owner_address   String
  session_address String
  encrypted_key   String
  chain_id        Int
  spending_limit  String
  amount_spent    String    @default("0")
  allowed_tokens  Json      @default("[]")
  expires_at      DateTime
  is_active       Boolean   @default(true)
  created_at      DateTime  @default(now())
  last_used_at    DateTime?

  @@index([owner_address])
  @@index([session_address])
  @@index([is_active])
  @@map("session_keys")
}

// ============================================================================
// AI Agent Authentication (SIWE + JWT)
// ============================================================================

model SiweNonce {
  id         String   @id @default(uuid())
  nonce      String   @unique
  expires_at DateTime
  used       Boolean  @default(false)
  created_at DateTime @default(now())

  @@index([nonce])
  @@index([expires_at])
  @@map("siwe_nonces")
}

model AiSession {
  id              String   @id @default(uuid())
  wallet_address  String
  token_hash      String   @unique
  refresh_hash    String   @unique
  expires_at      DateTime
  refresh_expires DateTime
  is_revoked      Boolean  @default(false)
  user_agent      String?
  ip_address      String?
  created_at      DateTime @default(now())
  last_active_at  DateTime @default(now())

  @@index([wallet_address])
  @@index([token_hash])
  @@index([refresh_hash])
  @@map("ai_sessions")
}

// ============================================================================
// ERC-8004 Agent Card & A2A Protocol Models
// ============================================================================

model AgentCard {
  id               String   @id @default(uuid())
  agent_id         String   @unique
  did              String   @unique
  display_name     String
  description      String?
  version          String   @default("1.0")
  capabilities     Json
  supported_tokens String[] @default([])
  supported_chains String[] @default([])
  a2a_endpoint     String?
  mcp_endpoint     String?
  auth_schemes     Json?
  reputation_score Float    @default(0)
  total_tasks      Int      @default(0)
  completed_tasks  Int      @default(0)
  owner_address    String
  signature        String?
  is_public        Boolean  @default(false)
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  agent Agent @relation(fields: [agent_id], references: [id], onDelete: Cascade)

  @@index([owner_address])
  @@index([is_public])
  @@map("agent_cards")
}

model A2AMessage {
  id            String    @id @default(uuid())
  message_type  String
  from_did      String
  from_address  String
  to_did        String?
  payload       Json
  signature     String
  nonce         String    @unique
  timestamp     DateTime
  status        String    @default("received")
  response_id   String?
  error_message String?
  task_id       String?
  proposal_id   String?
  created_at    DateTime  @default(now())
  processed_at  DateTime?

  @@index([from_did])
  @@index([task_id])
  @@index([nonce])
  @@map("a2a_messages")
}

model A2ATask {
  id          String   @id @default(uuid())
  status      String   @default("submitted")
  client_did  String
  server_did  String?
  description String?
  artifacts   Json?
  metadata    Json?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@index([client_did])
  @@map("a2a_tasks")
}

// ============================================================================
// Audit & Security Models
// ============================================================================

model AuditLog {
  id          String   @id @default(uuid())
  action      String
  actor       String
  target_type String?
  target_id   String?
  details     Json?
  ip_address  String?
  user_agent  String?
  created_at  DateTime @default(now())

  @@index([actor])
  @@index([action])
  @@index([created_at])
  @@map("audit_logs")
}

model SecurityAlert {
  id          String   @id @default(uuid())
  alert_type  String
  severity    String
  address     String
  description String
  details     Json?
  created_at  DateTime @default(now())

  @@index([address])
  @@index([severity])
  @@map("security_alerts")
}

model PaymentIntegrity {
  id              String   @id @default(uuid())
  payment_id      String
  client_hash     String
  server_hash     String
  integrity_valid Boolean
  discrepancies   Json?
  created_at      DateTime @default(now())

  @@index([payment_id])
  @@map("payment_integrity")
}

model PaymentRetryQueue {
  id           String    @id @default(uuid())
  tx_hash      String
  payment_data Json
  retry_count  Int       @default(0)
  status       String    @default("pending")
  next_retry   DateTime?
  created_at   DateTime  @default(now())

  @@index([status])
  @@index([tx_hash])
  @@map("payment_retry_queue")
}

// ============================================================================
// Offramp (Fiat Off-ramp) Models
// ============================================================================

model OfframpTransaction {
  id             String   @id @default(uuid())
  reference_id   String   @unique
  wallet_address String
  provider       String
  provider_tx_id String?
  crypto_amount  Float
  token          String
  chain_id       Int
  fiat_amount    Float
  fiat_currency  String
  payout_method  String
  status         String   @default("pending")
  tx_hash        String?
  error_message  String?
  quote_id       String?
  bank_details   String?
  created_at     DateTime @default(now())

  @@index([wallet_address])
  @@index([status])
  @@index([reference_id])
  @@map("offramp_transactions")
}

// ============================================================================
// Asset Distribution Models
// ============================================================================

model AssetDistribution {
  id                String   @id @default(uuid())
  payment_tx_hash   String
  distribution_tx   String?
  recipient_address String
  asset_type        String
  contract_address  String
  chain_id          Int      @default(8453)
  token_id          String?
  amount            String?
  status            String   @default("pending")
  error_message     String?
  payment_link_id   String?
  invoice_id        String?
  created_at        DateTime @default(now())

  @@index([recipient_address])
  @@index([payment_tx_hash])
  @@map("asset_distributions")
}

// ============================================================================
// Acquiring / Merchant Models
// ============================================================================

model Merchant {
  id             String   @id @default(uuid())
  user_id        String
  name           String
  description    String?
  logo_url       String?
  wallet_address String
  callback_url   String?
  status         String   @default("active")
  created_at     DateTime @default(now())

  user     AuthUser          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  api_keys MerchantApiKey[]
  orders   AcquiringOrder[]
  balances MerchantBalance[]

  @@index([user_id])
  @@index([wallet_address])
  @@map("merchants")
}

model MerchantApiKey {
  id              String   @id @default(uuid())
  merchant_id     String
  key_id          String   @unique
  key_secret_hash String
  name            String   @default("Default API Key")
  created_at      DateTime @default(now())

  merchant Merchant @relation(fields: [merchant_id], references: [id], onDelete: Cascade)

  @@index([merchant_id])
  @@index([key_id])
  @@map("merchant_api_keys")
}

model AcquiringOrder {
  id             String    @id @default(uuid())
  order_no       String    @unique
  merchant_id    String
  amount         Float
  currency       String    @default("USD")
  token          String    @default("USDC")
  notify_url     String?
  return_url     String?
  expires_at     DateTime
  metadata       Json?
  status         String    @default("pending")
  payment_method String?
  payer_address  String?
  tx_hash        String?
  paid_at        DateTime?
  created_at     DateTime  @default(now())
  updated_at     DateTime  @default(now())

  merchant Merchant @relation(fields: [merchant_id], references: [id], onDelete: Cascade)

  @@index([merchant_id])
  @@index([order_no])
  @@index([status])
  @@map("acquiring_orders")
}

model MerchantBalance {
  id          String   @id @default(uuid())
  merchant_id String
  token       String
  balance     String   @default("0")
  created_at  DateTime @default(now())
  updated_at  DateTime @default(now())

  merchant Merchant @relation(fields: [merchant_id], references: [id], onDelete: Cascade)

  @@unique([merchant_id, token])
  @@map("merchant_balances")
}

// ============================================================================
// Payment Links Models
// ============================================================================

model PaymentLink {
  id                     String    @id @default(uuid())
  link_id                String    @unique
  merchant_id            String?
  title                  String    @default("Payment")
  description            String?
  amount                 Float?
  currency               String    @default("USD")
  token                  String    @default("USDC")
  recipient_address      String
  amount_type            String    @default("fixed")
  min_amount             Float?
  max_amount             Float?
  expires_at             DateTime?
  redirect_url           String?
  signature              String?
  status                 String    @default("active")
  metadata               Json?     @default("{}")
  webhook_url            String?
  success_message        String?
  require_email          Boolean   @default(false)
  require_name           String?
  brand_color            String?
  logo_url               String?
  brand_name             String?
  distribute_asset       Boolean   @default(false)
  asset_type             String?
  asset_contract_address String?
  asset_token_id         String?
  asset_amount           String?
  total_payments         Int       @default(0)
  total_amount           Float     @default(0)
  total_views            Int       @default(0)
  created_at             DateTime  @default(now())
  updated_at             DateTime  @default(now())

  events PaymentLinkEvent[]

  @@index([link_id])
  @@index([merchant_id])
  @@index([recipient_address])
  @@index([status])
  @@map("payment_links")
}

model PaymentLinkEvent {
  id            String   @id @default(uuid())
  link_id       String
  event_type    String
  tx_hash       String?
  amount        Float?
  payer_address String?
  ip_address    String?
  user_agent    String?
  created_at    DateTime @default(now())

  payment_link PaymentLink @relation(fields: [link_id], references: [link_id], onDelete: Cascade)

  @@index([link_id])
  @@index([event_type])
  @@map("payment_link_events")
}

// ============================================================================
// MCP Subscriptions & Monetization Models
// ============================================================================

model McpSubscription {
  id                   String    @id @default(uuid())
  owner_address        String
  provider_id          String
  provider_name        String
  plan                 String
  status               String    @default("active")
  usage_count          Int       @default(0)
  monthly_cost         Int       @default(0)
  current_period_start DateTime?
  current_period_end   DateTime?
  created_at           DateTime  @default(now())

  @@index([owner_address])
  @@index([provider_id])
  @@index([status])
  @@map("mcp_subscriptions")
}

model MonetizeConfig {
  id            String   @id @default(uuid())
  owner_address String   @unique
  enabled       Boolean  @default(false)
  tiers         Json     @default("[]")
  default_tier  String?
  webhook_url   String?
  require_auth  Boolean  @default(true)
  created_at    DateTime @default(now())
  updated_at    DateTime @default(now())

  @@index([owner_address])
  @@map("monetize_configs")
}

model MonetizeApiKey {
  id            String    @id @default(uuid())
  owner_address String
  key           String    @unique
  name          String
  tier_id       String
  status        String    @default("active")
  usage_count   Int       @default(0)
  rate_limit    Int       @default(100)
  created_at    DateTime  @default(now())
  last_used_at  DateTime?

  @@index([owner_address])
  @@index([key])
  @@map("monetize_api_keys")
}

// ============================================================================
// Protocol Fee Models
// ============================================================================

model FeeConfig {
  id         String   @id @default(uuid())
  config_key String   @unique
  value      Json
  created_at DateTime @default(now())

  @@map("fee_config")
}

model ProtocolFee {
  id               String   @id @default(uuid())
  payment_id       String?
  batch_id         String?
  amount           Float
  fee_rate         Float
  base_fee         Float
  discount         Float    @default(0)
  net_fee          Float
  from_address     String
  treasury_address String
  token            String
  chain_id         Int
  status           String   @default("pending")
  tx_hash          String?
  tier             String
  created_at       DateTime @default(now())

  @@index([from_address])
  @@index([status])
  @@index([created_at])
  @@map("protocol_fees")
}

model MonthlyFeeSummary {
  id                String  @id @default(uuid())
  from_address      String
  month             String
  total_volume      Float   @default(0)
  transaction_count Int     @default(0)
  total_fees        Float   @default(0)
  total_discounts   Float   @default(0)
  net_fees          Float   @default(0)
  tier              String?

  @@unique([from_address, month])
  @@index([from_address])
  @@map("monthly_fee_summary")
}

// ============================================================================
// TRON Merchant Settlement Protocol - New Models (2026-02-08)
// ============================================================================

/**
 * 支付处理队列任务
 * 用于 Redis 队列的持久化备份和状态跟踪
 */
model PaymentQueueJob {
  id            String    @id @default(cuid())
  payment_id    String
  order_id      String
  tx_hash       String
  status        String    @default("pending") // pending, processing, completed, failed
  attempts      Int       @default(0)
  max_attempts  Int       @default(3)
  priority      Int       @default(10) // 1-10, 数字越小优先级越高
  error_message String?   @db.Text
  created_at    DateTime  @default(now())
  processed_at  DateTime?

  @@index([status])
  @@index([tx_hash])
  @@index([created_at])
  @@map("payment_queue_jobs")
}

/**
 * 自动生息存款记录
 * 跟踪商户在 JustLend 的存款和收益
 */
model YieldDeposit {
  id            String    @id @default(cuid())
  merchant_id   String
  amount        Decimal   @db.Decimal(20, 6)
  token         String    @default("USDT")
  principal     Decimal   @db.Decimal(20, 6)
  interest      Decimal   @default(0) @db.Decimal(20, 6)
  apy           Decimal   @db.Decimal(5, 2)
  status        String    @default("active") // active, withdrawn
  tx_hash       String?
  deposited_at  DateTime  @default(now())
  withdrawn_at  DateTime?

  @@index([merchant_id, status])
  @@index([deposited_at])
  @@map("yield_deposits")
}

/**
 * 区块信息缓存
 * 用于区块重组检测
 */
model BlockInfo {
  block_number Int      @id
  block_hash   String
  parent_hash  String
  timestamp    DateTime
  network      String   @default("tron") // tron, ethereum, base, etc.
  created_at   DateTime @default(now())

  @@index([network, block_number])
  @@map("block_info")
}

/**
 * 审计日志增强
 * 记录可疑交易和安全事件
 */
model SecurityAuditLog {
  id            String   @id @default(cuid())
  event_type    String // double_spend_attempt, suspicious_transaction, rate_limit_exceeded
  severity      String   @default("medium") // low, medium, high, critical
  tx_hash       String?
  merchant_id   String?
  ip_address    String?
  user_agent    String?
  details       Json
  created_at    DateTime @default(now())

  @@index([event_type])
  @@index([severity])
  @@index([merchant_id])
  @@index([created_at])
  @@map("security_audit_logs")
}

// ============================================================================
// RWA & Fiat Ramp Models (Added for HashKey/Rain/Transak Integration)
// ============================================================================

model CorporateCard {
  id             String   @id @default(uuid())
  external_id    String   @unique // Rain Card ID
  user_id        String
  status         String   @default("INACTIVE") // ACTIVE, FROZEN, CLOSED
  last4          String?
  currency       String   @default("USD")
  balance        Float    @default(0.0)
  spending_limit Float?
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  user         AuthUser          @relation(fields: [user_id], references: [id])
  transactions CardTransaction[]

  @@index([user_id])
  @@index([external_id])
  @@map("corporate_cards")
}

model CardTransaction {
  id                String   @id @default(uuid())
  external_id       String   @unique // Rain Transaction ID
  card_id           String
  merchant_name     String?
  merchant_category String?
  amount            Float
  currency          String
  status            String   // PENDING, COMPLETED, DECLINED
  type              String   // AUTHORIZATION, SETTLEMENT, REFUND
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  card CorporateCard @relation(fields: [card_id], references: [id])

  @@index([card_id])
  @@index([external_id])
  @@map("card_transactions")
}

model FiatOrder {
  id              String   @id @default(uuid())
  order_id        String   @unique // Transak Order ID
  user_id         String?
  provider        String   @default("TRANSAK") // TRANSAK, MOONPAY
  status          String
  fiat_amount     Float
  fiat_currency   String
  crypto_amount   Float
  crypto_currency String
  wallet_address  String
  tx_hash         String?
  network         String?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  user AuthUser? @relation(fields: [user_id], references: [id])

  @@index([user_id])
  @@index([order_id])
  @@map("fiat_orders")
}

// ============================================================================
// Enterprise Ledger System (总账系统)
// ============================================================================

/// User balance ledger - cached balance per user/token/chain
/// This is the source of truth for available and locked balances
model UserBalance {
  id            String   @id @default(uuid())
  user_address  String
  token         String   // USDC, USDT, ETH, etc.
  chain         String   // ethereum, base, arbitrum, tron, etc.
  available     Decimal  @default(0) @db.Decimal(36, 18) // Available for spending
  locked        Decimal  @default(0) @db.Decimal(36, 18) // Locked for pending txs
  total         Decimal  @default(0) @db.Decimal(36, 18) // available + locked
  version       Int      @default(0) // Optimistic locking
  last_synced   DateTime @default(now()) // Last on-chain sync
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@unique([user_address, token, chain])
  @@index([user_address])
  @@map("user_balances")
}

/// Double-entry ledger entries - every financial event creates a debit+credit pair
/// Immutable: entries are never updated or deleted
model LedgerEntry {
  id               String   @id @default(uuid())
  idempotency_key  String   // Links debit/credit pair, prevents duplicates
  account_address  String   // The account this entry belongs to
  entry_type       String   // DEBIT or CREDIT
  category         String   // payment, fee, refund, settlement, deposit, withdrawal, lock, unlock
  amount           Decimal  @db.Decimal(36, 18)
  token            String
  chain            String
  balance_before   Decimal  @db.Decimal(36, 18)
  balance_after    Decimal  @db.Decimal(36, 18)
  counterparty     String?  // The other side of the transaction
  reference_type   String?  // payment, batch_payment, subscription, settlement, etc.
  reference_id     String?  // ID of the referenced entity
  tx_hash          String?
  description      String?
  metadata         Json?
  created_at       DateTime @default(now())

  @@index([idempotency_key])
  @@index([account_address, token, chain])
  @@index([reference_type, reference_id])
  @@index([tx_hash])
  @@index([created_at])
  @@map("ledger_entries")
}

/// Idempotency keys - prevents duplicate payment processing
model IdempotencyKey {
  id             String    @id @default(uuid())
  key            String    @unique // Client-provided or system-generated key
  user_address   String
  request_path   String    // API endpoint
  request_hash   String    // SHA-256 of request body
  response_code  Int?
  response_body  Json?
  status         String    @default("processing") // processing, completed, failed
  created_at     DateTime  @default(now())
  expires_at     DateTime  // Auto-expire after 24h
  completed_at   DateTime?

  @@index([user_address])
  @@index([expires_at])
  @@map("idempotency_keys")
}

// ============================================================================
// Batch Payment Items (批量支付明细)
// ============================================================================

/// Individual items within a batch payment - tracks each recipient separately
model BatchItem {
  id              String    @id @default(uuid())
  batch_id        String    // References BatchPayment.batch_id
  index           Int       // Position in batch (0-based)
  recipient       String    // Recipient address
  amount          Decimal   @db.Decimal(36, 18)
  token           String
  chain           String
  status          String    @default("pending") // pending, processing, completed, failed, skipped
  tx_hash         String?
  error_message   String?
  retry_count     Int       @default(0)
  max_retries     Int       @default(3)
  gas_used        BigInt?
  energy_used     BigInt?
  fee_amount      Decimal?  @db.Decimal(36, 18)
  ledger_entry_id String?   // Links to LedgerEntry
  created_at      DateTime  @default(now())
  completed_at    DateTime?

  @@unique([batch_id, index])
  @@index([batch_id])
  @@index([status])
  @@index([recipient])
  @@map("batch_items")
}

// ============================================================================
// Cross-Chain Transaction State Machine (跨链交易状态机)
// ============================================================================

/// Cross-chain transaction tracking with full state machine
model CrossChainTransaction {
  id                String    @id @default(uuid())
  user_address      String
  type              String    // swap, bridge, transfer
  provider          String    // rango, zetachain, manual
  source_chain      String
  source_token      String
  source_amount     Decimal   @db.Decimal(36, 18)
  source_tx_hash    String?
  dest_chain        String
  dest_token        String
  dest_amount       Decimal?  @db.Decimal(36, 18)
  dest_tx_hash      String?
  recipient_address String?   // Defaults to user_address if null
  state             String    @default("initiated") // initiated, source_confirmed, bridging, dest_pending, completed, failed, refunded
  sub_state         String?   // Provider-specific sub-state
  slippage_bps      Int?      // Slippage in basis points
  route_data        Json?     // Provider route/quote data
  error_message     String?
  error_code        String?
  retry_count       Int       @default(0)
  estimated_time    Int?      // Estimated completion in seconds
  idempotency_key   String?   @unique
  ledger_entry_id   String?
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt
  completed_at      DateTime?

  state_transitions CrossChainStateTransition[]

  @@index([user_address])
  @@index([state])
  @@index([source_tx_hash])
  @@index([dest_tx_hash])
  @@index([created_at])
  @@map("cross_chain_transactions")
}

/// State transition log for cross-chain transactions
model CrossChainStateTransition {
  id             String   @id @default(uuid())
  transaction_id String
  from_state     String
  to_state       String
  trigger        String   // user_action, blockchain_event, timeout, error
  details        Json?
  created_at     DateTime @default(now())

  transaction CrossChainTransaction @relation(fields: [transaction_id], references: [id], onDelete: Cascade)

  @@index([transaction_id])
  @@map("cross_chain_state_transitions")
}

// ============================================================================
// Settlement & Reconciliation (清算对账)
// ============================================================================

/// Settlement records - periodic reconciliation between on-chain and off-chain
model SettlementRecord {
  id                  String    @id @default(uuid())
  settlement_id       String    @unique // Human-readable ID (e.g., STL-2026-02-001)
  user_address        String
  period_start        DateTime
  period_end          DateTime
  token               String
  chain               String
  total_debits        Decimal   @db.Decimal(36, 18) // Sum of all debits in period
  total_credits       Decimal   @db.Decimal(36, 18) // Sum of all credits in period
  net_amount          Decimal   @db.Decimal(36, 18) // credits - debits
  on_chain_balance    Decimal?  @db.Decimal(36, 18) // Actual on-chain balance at settlement
  ledger_balance      Decimal?  @db.Decimal(36, 18) // Ledger balance at settlement
  discrepancy         Decimal?  @db.Decimal(36, 18) // on_chain - ledger (should be 0)
  entry_count         Int       @default(0)
  status              String    @default("pending") // pending, processing, reconciled, discrepancy_found, resolved
  resolution_notes    String?
  resolved_by         String?
  created_at          DateTime  @default(now())
  completed_at        DateTime?

  @@index([user_address])
  @@index([status])
  @@index([period_start, period_end])
  @@map("settlement_records")
}

// ============================================================================
// Risk Control & Compliance (风控与合规)
// ============================================================================

/// Risk assessment for transactions
model RiskAssessment {
  id               String   @id @default(uuid())
  reference_type   String   // payment, batch_payment, cross_chain, withdrawal
  reference_id     String
  user_address     String
  recipient        String?
  amount           Decimal  @db.Decimal(36, 18)
  token            String
  chain            String
  risk_score       Int      // 0-100 (0=safe, 100=blocked)
  risk_level       String   // low, medium, high, critical, blocked
  factors          Json     // Array of risk factors with scores
  decision         String   // approve, review, block
  reviewed_by      String?  // If manually reviewed
  review_notes     String?
  created_at       DateTime @default(now())

  @@index([reference_type, reference_id])
  @@index([user_address])
  @@index([risk_level])
  @@index([decision])
  @@map("risk_assessments")
}

/// Compliance screening results (sanctions, PEP, etc.)
model ComplianceCheck {
  id              String   @id @default(uuid())
  address         String   // Address being checked
  check_type      String   // sanctions, pep, adverse_media, address_risk
  provider        String   // chainalysis, elliptic, internal
  result          String   // clear, match, potential_match, error
  risk_score      Int?     // Provider-specific risk score
  details         Json?    // Full screening results
  expires_at      DateTime // Results validity period
  created_at      DateTime @default(now())

  @@index([address])
  @@index([check_type])
  @@index([expires_at])
  @@map("compliance_checks")
}
